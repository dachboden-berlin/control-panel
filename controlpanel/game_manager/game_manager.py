import osimport sysfrom types import SimpleNamespaceimport pygame as pgimport pygame_shadersimport importlib.resourcesimport ioimport inspectimport controlpanelfrom controlpanel import apifrom controlpanel.api import servicesfrom .games import BaseGame, FallbackGamefrom anaconsole import DeveloperOverlay, console_command, Autocompletefrom .utils import get_output_size, get_display_flagsfrom typing import TypeVarimport platformfrom pathlib import Pathif platform.system() == "Windows":  # Circumvent windows display setting "scale" factor resulting in blurry images    import ctypes    ctypes.windll.user32.SetProcessDPIAware()T = TypeVar("T", bound=BaseGame)class GameManager:    def __init__(            self,            resolution: tuple[int, int] | None,            dev_args: list[str] | None = None, *,            is_fullscreen: bool,            use_shaders: bool,            stretch_to_fit: bool,            enable_cheats: bool,    ):        pg.init()        self._set_icon_and_caption()        self._games: dict[str, BaseGame] = dict()        self._base_cwd = os.getcwd()        self._current_game: BaseGame | None = None        self._resolution = resolution        if resolution:            self._screen = pg.display.set_mode(get_output_size(resolution, is_fullscreen, use_shaders, stretch_to_fit),                                               flags=get_display_flags(is_fullscreen, use_shaders))            self.use_shaders = use_shaders            if use_shaders:                self._shader = pygame_shaders.Shader(pygame_shaders.DEFAULT_VERTEX_SHADER, "controlpanel/shaders/effect.glsl", self._screen)                self._crt_shader = pygame_shaders.Shader(pygame_shaders.DEFAULT_VERTEX_SHADER, "controlpanel/shaders/crt.frag", self._screen)        self._joysticks: dict[int, pg.joystick.JoystickType] = dict()        self._dev_overlay = DeveloperOverlay(self._screen if resolution else pg.Surface((1280, 720)),                                             namespaces={                                                 "game_manager": self,                                                 "cp": controlpanel,                                                 "api": api,                                                 "event_manager": api.services.event_manager,                                             },                                             enable_cheats=enable_cheats,                                             target_framerate=None)        if services.event_manager is not None:            setattr(self._dev_overlay.namespace, "devices", SimpleNamespace(**services.event_manager.devices))        self._running = True        self._dev_args: list[str] = self.parse_dev_args(dev_args) if dev_args is not None else []    @staticmethod    def _set_icon_and_caption():        with importlib.resources.open_binary(__package__, "icon.png") as file:            pg.display.set_icon(pg.image.load(io.BytesIO(file.read())))        pg.display.set_caption("Control Panel")    @staticmethod    def parse_dev_args(input_list: list[str]) -> list[str]:        output: list[str] = []        current: list[str] = []        for item in input_list:            if item.startswith('-'):                if current:                    output.append(" ".join(current))                current = [item.lstrip('-').replace("-", "_")]            else:                current.append(item)        if current:            output.append(" ".join(current))        return output    def add_game(self, game: T, make_current: bool = False) -> T:        if self._games.get(game.name) is not None:            raise ValueError(f"Game with name {game.name} already exists!")        self._games[game.name] = game        setattr(self._dev_overlay.namespace, game.name.lower().replace(" ", "_"), game)  # todo: private attr        game._joysticks = self._joysticks        if make_current:            self.change_game(game.name)        return game    def get_game(self, name: str | None = None) -> BaseGame | None:        if name is None:            return self._current_game        return self._games.get(name)    def change_game_autocomplete(self, text: str) -> tuple[int, list[Autocomplete.Option]]:        return 0, list(Autocomplete.Option(name, str(game.__doc__ or "")) for name, game in self._games.items() if name.startswith(text))    # TODO: Fix! (uses old scripts system)    # @staticmethod    # def load_script_autocomplete(text: str) -> tuple[int, list[Autocomplete.Option]]:    #     scripts_module = os.path.dirname(controlpanel.scripts.__file__)    #     options: list[Autocomplete.Option] = []    #     for file in os.listdir(scripts_module):    #         if file.removesuffix(".py") in api.loaded_scripts.keys():    #             continue    #         if not file.startswith(text) or file.startswith("__"):    #             continue    #         options.append(Autocomplete.Option(file, ""))    #     return 0, options    @console_command    def list_scripts(self):        """List all currently loaded scripts"""        if not api.loaded_scripts:            print("No scripts are currently loaded.")            return        print("Currently loaded scripts:")        for script_name in api.loaded_scripts:            print(f"- {script_name}")    # TODO: see load_scripts_autocomplete    # @console_command(is_cheat_protected=True, autocomplete_function=load_script_autocomplete)    # def load_script(self, script_name: str):    #     """Load a script in scripts/"""    #     api.load_scripts([script_name,])    @console_command    def list_games(self):        """List all currently loaded games"""        print("Currently loaded games:")        for game_name in self._games.keys():            print(f"- {game_name}")    @console_command(is_cheat_protected=True, autocomplete_function=change_game_autocomplete)    def change_game(self, name: str) -> None:        """Changes the current game. Game needs to have been loaded first."""        game: BaseGame | None = self._games.get(name)        if not game:            print(f"No game named {name} is currently loaded.")            return        if game.working_directory_override:            os.chdir(game.working_directory_override)        else:            os.chdir(self._base_cwd)        self._current_game = game        self._dev_overlay._target_framerate = game._base_tickrate    @console_command("screenshot")    def take_screenshot(self, filename: str | None = None) -> None:        """Takes a screenshot and saves it as PNG in the cwd."""        if not self._current_game:            print("Cannot take screenshot if no game is running.")            return        if not filename:            from datetime import datetime            timestamp = datetime.now().strftime("%d%m%Y-%H%M%S")            filename = f"{self._current_game.name}_{timestamp}.png"        elif not any(filename.lower().endswith(filetype) for filetype in (".png", ".jpg", ".tga", ".bmp")):            filename += ".png"        pg.image.save(self._current_game.screen, filename)        print(f"Exported screenshot to {filename}")    @console_command("quit", "exit", is_cheat_protected=True)    def quit(self):        """Quit the game"""        self._running = False    @console_command(is_cheat_protected=True)    def load_game(self, module_name: str, module_directory: Path | str = ".", *args) -> None:        """Dynamically load a game from a different directory. Example: 'load_game game_module.main ../GameDirectory'"""        from controlpanel.game_manager import BaseGame  # TODO: remove lazy import?        # If an extra_path is provided, join it with CWD and add to sys.path        if module_directory:            # Make sure to join the provided extra_path with the current working directory            module_directory = Path(module_directory).resolve()  # Resolves the path to an absolute path            sys.path.append(str(module_directory))        try:            # Try importing the game module            print(f"Attempting to load {module_name} from {module_directory}...")            game_module = importlib.import_module(module_name)        except ModuleNotFoundError as e:            print(f'Failed to load module "{module_name}" due to missing module: {e}')            return        # Scan the module for classes that inherit from BaseGame        games = []        for name, obj in inspect.getmembers(game_module, inspect.isclass):            # Make sure the class is defined in the module (not just imported into it)            if issubclass(obj, BaseGame) and obj is not BaseGame and obj.__module__ == game_module.__name__:                games.append(obj)        if not games:            print(f'Cannot load game: Successfully imported module {module_name},'                  f'but failed to find any instance of BaseGame inside.')            return        # Instantiate and use them        for cls in games:            os.chdir(module_directory)            instance = cls(*args)            instance._working_directory_override = str(module_directory)            print(f"Successfully loaded {cls.__name__}")            self.add_game(instance, True)    def run_headless(self):        while True:            string = input(">>> ")            self._dev_overlay.dev_console.handle_command(string, suppress_logging=True)    def run(self) -> None:        if not self._resolution:            self.run_headless()        if self._current_game is None and self._games:            self._current_game = list(self._games.values())[0]        for arg in self._dev_args:            self._dev_overlay.dev_console.handle_command(arg, suppress_logging=True, ignore_cheat_protection=True)        clock = pg.time.Clock()        if self._current_game is None:            self.add_game(FallbackGame(), make_current=True)        t = 0        while self._running:            events: list[pg.Event] = pg.event.get()            game_events: list[pg.Event] = []  # events that will be passed to current game            for event in events:                if event.type == pg.QUIT:                    pg.quit()                elif event.type == pg.JOYDEVICEADDED:                    joy = pg.joystick.Joystick(event.device_index)                    self._joysticks[joy.get_instance_id()] = joy                elif event.type == pg.KEYDOWN and event.key == pg.K_F12:                    self.take_screenshot()                elif self._dev_overlay._trickle_down_event(event):                    continue                else:                    game_events.append(event)            if not self._current_game:                return            self._current_game.handle_events(game_events)            self._current_game.update()            self._current_game.render()            self._screen.blit(self._current_game.screen, (0, 0))            self._dev_overlay.render()            if self.use_shaders:                crt_shader_uniforms = {                    '_Curvature': 8.0,                    '_VignetteWidth': 40.0,                    '_ScreenParams': (960, 540),                    '_ScanlineHeight': 2.0 / 540,                    '_ScanlineStrength': 1.2,                }                for key, val in crt_shader_uniforms.items():                    self._crt_shader.send(key, val)                self._shader.send("time", t)                self._shader.render_direct(pg.Rect(0, 0, 960, 540))                self._crt_shader.render_direct(pg.Rect(0, 0, 960, 540))            pg.display.flip()            dt_ms = clock.tick(self._current_game.tickrate)            t += dt_ms            self._current_game._dt = dt_ms / 1000 * self._current_game.timescale        pg.quit()